/*
 * Copyright Charles Gray
 * All rights reserved
 * Contact author for EULA
 */
package v;

import c.JTableUtils;
import java.awt.Dimension;
import java.awt.Toolkit;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import javax.swing.table.DefaultTableModel;
import v.Log.Logfile;
import java.lang.ArrayIndexOutOfBoundsException;
import java.sql.SQLException;
import java.sql.ResultSet;
import m.db.ResultSetTableModel;
import javax.swing.JTable;
import javax.swing.JFrame;
import javax.swing.JWindow;
import javax.swing.SwingUtilities;
import v.File.ExportToTextFileTableModel;
import java.awt.Point;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.JMenuItem;
import javax.swing.JPopupMenu;
import m.Common;
import javax.swing.JComboBox;
import java.awt.Desktop;
import java.net.URI;
import java.net.URISyntaxException;
import java.io.IOException;




/**
 * Provides a JFrame with ScrollPane and JTable that is populated manually via addRow method.  There is no database connection.
 * TableModel is set via constructor or method  setTableModel(Object[] columns).
 * Title of JFrame is set via constructor or method setFrameTitle(String titlel).
 * Usage: Construct this class, add rows via addRow(), and then call adjustColumns() to resize column widths.
 * Read table contents via method getValueAt(row, column);
 * If you want to invoke "Charlie's" column resize method remember to call adjustColumns() after all rows have been added.
 * Then call resize().  I haven't been able to figure out how to resize from within the same JFrame class.
 * Dependencies: v.Log.Logfile
 * @author chas
 */
public class TableCallsign extends javax.swing.JFrame
{
private final Logfile logger;
private DefaultTableModel dtml;
private int columnNumber;  // number of columns in definition of DefaultTableModel.  Used to check number of columns in addRow()
private Dimension screen;
private TableColumnAdjuster tca;
public Dimension dimFrame;
public boolean debug = true;
private PopUpCallsign PUC;



  /**
   * Creates new form Table
   */
  public TableCallsign()
    {
    this(null, null, null, null);
    }

public TableCallsign(Logfile logger){this(logger, null, null, null);}  
  
public TableCallsign(Logfile logger, Object[] columns)
  {
  this(logger, columns, null, null);
  }
  
public TableCallsign(Logfile logger, Object[] columns, String title)
  {
  this(logger, columns, title, null);
  }

public TableCallsign(Logfile logger, String title)
  {
  this(logger, null, title, null);
  }


public TableCallsign(Logfile logger, Object[] columns, String title, Object[][] rowData)
  {
  if( logger == null) 
    {
    String className = this.getClass().getName();
    this.logger = new Logfile(className, className + ".log");
    }
  else this.logger = logger;
  initComponents();
  if(title != null) this.setFrameTitle(title);
  if( columns != null) this.setTableModel(columns);
  if(rowData != null)this.addRows(rowData);
  this.screen = Toolkit.getDefaultToolkit().getScreenSize();
  this.setLocation();
  this.PUC = new PopUpCallsign(this.logger);
  this.setVisible(true);
  } // end Table constructor
  

public TableCallsign(Logfile logger, ResultSetTableModel rstml, String title)
  {
  if( logger == null) 
    {
    String className = this.getClass().getName();
    this.logger = new Logfile(className, className + ".log");
    }
  else this.logger = logger;
  initComponents();
  if(title != null) this.setFrameTitle(title); else this.setFrameTitle("What, no title?");
  this.screen = Toolkit.getDefaultToolkit().getScreenSize();
  this.setTableModel(rstml.getColumnNames());
  this.addResultSetTableModel(rstml);
  this.setLocation();
  this.setVisible(true);
  this.PUC = new PopUpCallsign(this.logger);
  } // end Table constructor
  
  
  
  /**
   * This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
  @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        jTable1 = new javax.swing.JTable();
        labelStatus = new javax.swing.JLabel();
        jMenuBar1 = new javax.swing.JMenuBar();
        jMenu1 = new javax.swing.JMenu();
        jMenuItemExportToTextFile = new javax.swing.JMenuItem();
        jMenu2 = new javax.swing.JMenu();
        jMenuItemColumnLayout = new javax.swing.JMenuItem();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setTitle("Table Display");

        jTable1.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null},
                {null, null, null, null}
            },
            new String [] {
                "Title 1", "Title 2", "Title 3", "Title 4"
            }
        ));
        jTable1.setAutoResizeMode(javax.swing.JTable.AUTO_RESIZE_ALL_COLUMNS);
        jTable1.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jTable1MouseClicked(evt);
            }
        });
        jScrollPane1.setViewportView(jTable1);

        labelStatus.setText("Status");

        jMenu1.setText("File");

        jMenuItemExportToTextFile.setText("Export to text file");
        jMenuItemExportToTextFile.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemExportToTextFileActionPerformed(evt);
            }
        });
        jMenu1.add(jMenuItemExportToTextFile);

        jMenuBar1.add(jMenu1);

        jMenu2.setText("Edit");

        jMenuItemColumnLayout.setText("Change Column Layout");
        jMenuItemColumnLayout.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemColumnLayoutActionPerformed(evt);
            }
        });
        jMenu2.add(jMenuItemColumnLayout);

        jMenuBar1.add(jMenu2);

        setJMenuBar(jMenuBar1);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(labelStatus)
                .addContainerGap(1322, Short.MAX_VALUE))
            .addComponent(jScrollPane1)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 750, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(labelStatus))
        );

        labelStatus.getAccessibleContext().setAccessibleName("statusLabel");

        pack();
    }// </editor-fold>//GEN-END:initComponents

 private void jMenuItemColumnLayoutActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_jMenuItemColumnLayoutActionPerformed
 {//GEN-HEADEREND:event_jMenuItemColumnLayoutActionPerformed
 String modes[] = { "Resize All Columns", "Resize Last Column", "Resize Next Column",
        "Resize Off", "Resize Subsequent Columns", "Charlie Adjust" };
    
 final int modeKey[] = { JTable.AUTO_RESIZE_ALL_COLUMNS, JTable.AUTO_RESIZE_LAST_COLUMN,
        JTable.AUTO_RESIZE_NEXT_COLUMN, JTable.AUTO_RESIZE_OFF,
        JTable.AUTO_RESIZE_SUBSEQUENT_COLUMNS, 0 };
 JWindow jf = new JWindow(this);   
 JComboBox resizeModeComboBox = new JComboBox(modes);
 jf.add(resizeModeComboBox);
 Dimension screen = Toolkit.getDefaultToolkit().getScreenSize();
 jf.setLocation(((screen.width - this.getSize().width) /2),((screen.height - this.getSize().height) / 2));
 jf.pack();
 jf.setVisible(true);
 resizeModeComboBox.setVisible(true);
    ItemListener itemListener = new ItemListener() {
      public void itemStateChanged(ItemEvent e) {
        jTable1.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
        JComboBox source = (JComboBox) e.getSource();
        /* modeKey[index] 
        0=AUTO_RESIZE_ALL_COLUMNS, 
        1=AUTO_RESIZE_LAST_COLUMN,
        2=AUTO_RESIZE_NEXT_COLUMN, 
        3=AUTO_RESIZE_OFF,
        4=AUTO_RESIZE_SUBSEQUENT_COLUMNS, 
        5=Charlie's method 
        */
        int index = source.getSelectedIndex();
        if(index==5)
          {
          logger.println("User selected Charlie column widths.");
          adjustColumns();
          }
        else jTable1.setAutoResizeMode(modeKey[index]);
      }
    };
    resizeModeComboBox.addItemListener(itemListener);
    
 }//GEN-LAST:event_jMenuItemColumnLayoutActionPerformed

    private void jMenuItemExportToTextFileActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemExportToTextFileActionPerformed
    String textOutputParams[]= {"table_dump",".csv","|","","\r\n"};
    ExportToTextFileTableModel etf = new ExportToTextFileTableModel(dtml, textOutputParams, this.getTitle().replace(' ','_'), "Pipe delimited .csv file");


    }//GEN-LAST:event_jMenuItemExportToTextFileActionPerformed

    private void jTable1MouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jTable1MouseClicked
     int rowCountl = this.jTable1.rowAtPoint(evt.getPoint());
     int colCountl = this.jTable1.columnAtPoint(evt.getPoint());
     Point pt = evt.getPoint();
     String strValue=(String)jTable1.getValueAt(rowCountl, colCountl);
        System.out.println("Mouse clicked at row=" + rowCountl + ", column=" + colCountl + " at point x=" + pt.x + ", y=" + pt.y + ", value=" + strValue);
     this.PUC.callsign = strValue;
     if(colCountl==0)this.PUC.show(evt.getComponent(), evt.getX(), evt.getY());
    }//GEN-LAST:event_jTable1MouseClicked

  /**
   * @param args the command line arguments
   */
  public static void main(String args[])
    {
    /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
     * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
     */
    try
    {
      for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels())
      {
        if ("Nimbus".equals(info.getName()))
        {
          javax.swing.UIManager.setLookAndFeel(info.getClassName());
          break;
        }
      }
    } catch (ClassNotFoundException ex)
    {
      java.util.logging.Logger.getLogger(Table.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (InstantiationException ex)
    {
      java.util.logging.Logger.getLogger(Table.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (IllegalAccessException ex)
    {
      java.util.logging.Logger.getLogger(Table.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (javax.swing.UnsupportedLookAndFeelException ex)
    {
      java.util.logging.Logger.getLogger(Table.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    }
        //</editor-fold>
        //</editor-fold>

    /* Create and display the form */
    java.awt.EventQueue.invokeLater(new Runnable()
      {
      public void run()
        {
        new Table().setVisible(true);
        }
      });
    }
  

/*
 * Set title of Frame
 * Called by constructor.
 */  
public void setFrameTitle(String titlel)
  {
  this.setTitle(titlel);
  }
  
  
 /*
  * Create TableModel to define columns.
  * Called by constructor
  */
public boolean setTableModel(Object[] columns)
  {
  // DefaultTableModel is an implementation of TableModel that uses a Vector of Vectors to store the cell value objects. 
  DefaultTableModel dtmll;
  // construct DefaultTableModel specifying column names, but no rows.  Rows are added iteratively in method deviceList.
  // constructor DefaultTableModel(Vector columnNames, int rowCount)
  // dtmll = new DefaultTableModel(new Object[] { "Bus", "Device","Vendor ID", "Vendor Name", "Product ID", "Product Name", "Product Detail", "Port", "Speed", "MaxPacketSize", "Device Class", "Parent Dev.", "Max Power", "Intf. Count", "Intf. Class", "ETransfer Type", "ESynch Type"},0);
  dtmll = new DefaultTableModel(columns,0);
  // return dtmll;
  this.columnNumber = columns.length;
  this.dtml=dtmll;
  this.jTable1.setModel(this.dtml);
  jTable1.setAutoResizeMode(javax.swing.JTable.AUTO_RESIZE_ALL_COLUMNS);
  // Below is a template as to the manner in which rows are added in method deviceList.
  // dtmll.addRow(new Object[]{"1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16"});
  labelStatus.setText("Newly initialized model.  0 rows.");
  return true;
  } // end method setTableModel



/**
 * Called by this.addrows()
 * @param rowData
 * @return 
 */
public boolean addRow(Object[] rowData)
  {
  if(rowData.length != this.columnNumber){logger.e("Number of columns in addRow() call does not match number of columns defined in DefaultTableModel."); return false;}
  this.dtml.addRow(rowData);  // row data is added to the DefaultTableModel
  this.labelStatus.setText("Row count=" + String.valueOf(this.dtml.getRowCount()));
  //this.jTable1.revalidate();this.jTable1.resize(0,2000);this.jTable1.repaint();jTable1.paintImmediately(0,0,1000,1000);
  return true;
  }


/**
 * Called by constructor.
 * @param rowData
 * @return 
 */
public boolean addRows(Object[][] rowData)
  /* example
  * Object[][] rowData={ {"cell11", "cell12", "cell13"},{"cell21", "cell22", "cell23"},{"cell31", "cell32", "cell33"},{"cell41", "cell42", "cell43", }};
  */
  {
  if(rowData == null){logger.e("Null row data in Table.addRows()"); return false;}
  for(int x=0; x< rowData.length; x++) this.addRow(rowData[x]);
  this.labelStatus.setText("Row count=" + String.valueOf(this.dtml.getRowCount()));
  return true;
  }

/**
 * Populate table with contents of ResultSet
 * This will require that the ResultSet be replenished with a fresh database query if table is TYPE_FORWARD_ONLY
 * @param row
 * @param column
 * @return 
 */
public boolean addResultSetTableModel(ResultSetTableModel rstml)
  {
  int rowcount=rstml.getRowCount();
  int colcount=rstml.getColumnCount();
  Object rowArray[] = new Object[colcount];
  for(int rowi=0; rowi < rowcount; rowi++)
    {
    for(int coli=0; coli < colcount; coli++)rowArray[coli]=rstml.getValueAt(rowi, coli);
    if(!this.addRow(rowArray)) return false;
    }
  this.adjustColumns();
  return true;
  }

    
public Object getValueAt(int row, int column)
  {
  try
    {
    return this.dtml.getValueAt(row, column);
    }
  catch(ArrayIndexOutOfBoundsException aiob){logger.ee("Failed to get TableModel " + this.getTitle() + " row=" + row + ", column=" + column, aiob); return null;}
  }
  

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JMenu jMenu1;
    private javax.swing.JMenu jMenu2;
    private javax.swing.JMenuBar jMenuBar1;
    private javax.swing.JMenuItem jMenuItemColumnLayout;
    private javax.swing.JMenuItem jMenuItemExportToTextFile;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTable jTable1;
    private javax.swing.JLabel labelStatus;
    // End of variables declaration//GEN-END:variables

 
 
 
 
/**
 * Called by ItemLayout change
 */
public void adjustColumns()
  {
  jTable1.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
  this.tca = new TableColumnAdjuster(this.jTable1);
  tca.adjustColumns();
  this.dimFrame = this.getSize();
  int height=(int)(dimFrame.height * 0.95);
  if(debug)System.out.println("columnWidthTotals=" + tca.columnWidthTotals + " screen width=" + this.screen.width);
  if(tca.columnWidthTotals > this.screen.width) tca.columnWidthTotals = this.screen.width;
  this.dimFrame.width=tca.columnWidthTotals + (int)(jTable1.getColumnCount() * 4);
  this.dimFrame.height=height;
  this.setSize(dimFrame);
  this.setLocation();
  this.repaint(0,0,1000,1000);
  if(debug)System.out.println("Table # columns=" + jTable1.getColumnCount() + ", table width=" + jTable1.getSize().width + ", ScrollPane width=" + jScrollPane1.size().width  + ", Frame width=" + this.getSize().width);
  //this.resize2();
  } // end adjustColumns
 

/**
 * Called by this.adjustColumns()
 * @return 
 */
public int resize2()
  {
  Dimension dimFrame = this.getSize();
  Dimension dimFrame2;
  int widthTca=tca.columnWidthTotals;
  Dimension dimTable = this.jTable1.getSize();
  Dimension dimScrollPane = this.jScrollPane1.getSize();
  if(debug)System.out.println("columnWidthTotals=" + widthTca + " screen width=" + this.screen.width);
  widthTca=widthTca + 8;
  if(widthTca > this.screen.width) widthTca = this.screen.width;
  dimScrollPane.width=widthTca + 4;
  dimTable.width=widthTca;
  if(debug)System.out.println("Table width=" + jTable1.getSize().width + ", ScrollPane width=" 
     + jScrollPane1.size().width  + ", Frame width=" + this.getSize().width + " or " + this.getWidth());
  dimFrame2 = new Dimension(widthTca,(int)dimFrame.getHeight());
  this.setSize(dimFrame2);
  if(debug)System.out.println("Table width=" + jTable1.getSize().width + ", ScrollPane width=" 
     + jScrollPane1.size().width  + ", Frame width=" + this.getSize().width + " or " + this.getWidth());
  setLocation(((screen.width - this.getSize().width) /2),((screen.height - this.getSize().height) / 2));
  this.revalidate();
  this.repaint();
  //this.pack();  Don't do this.  It will cause a resize of the JFrame
  if(debug)System.out.println("Table width=" + jTable1.getSize().width + ", ScrollPane width=" 
     + jScrollPane1.size().width  + ", Frame width=" + this.getSize().width + " or " + this.getWidth());
  return widthTca;
  }
 
private void setLocation()
  {
  this.setLocation(((screen.width - this.getSize().width) /2),((screen.height - this.getSize().height) / 2));
  }


/*
private void callsignMenu(String callsign, Point locPoint)
  {
  JComboBox csmComboBox = new JComboBox<>();
  csmComboBox.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "Query at QRZCQ", "Query at HamQTH", "Query at HamCall", "Query at QRZ", "Query at RadioReference", "Query at QRZ.ru" }));
  this.add(csmComboBox);
  csmComboBox.setLocation(locPoint);
  csmComboBox.setSelectedIndex(0);
  csmCooBox.setVisible(true);
  this.repaint();
  System.out.println("Made a combobox");
  } // end callsignMenu()
*/




// This class handles right-click menu for table database/connection
// Use of this class assumes initialization of Common.TableDatabase, which is FrameMain.jtableConn
// Assignment of Common.TableDatabase for Connection table occurrs in FrameMain constructor.
class PopUpCallsign extends JPopupMenu 
  {
  private final JMenuItem item1, item2, item3, item4, item5;
  private final Logfile logger;
  public String callsign;
  public PopUpCallsign(Logfile logger)
    {
    this.logger = logger;
    item1 = new JMenuItem("Query at QRZCQ");
    item2 = new JMenuItem("Query at HamQTH");
    item3 = new JMenuItem("Query at HamCall");
    item4 = new JMenuItem("Query at QRZ");
    item5 = new JMenuItem("Query at QRZ.ru");
    String[] queryArray = {"https://www.qrzcq.com","https://www.hamqth.com","https://hamcall.net","https://www.qrz.com","https://qrz.ru"};
    String URIString="Uninitialized";
    item1.addActionListener(new ActionListener() 
      {
      public void actionPerformed(ActionEvent e) 
        {
        desktopCall(queryArray[0]+ "/call/" + callsign); // qrzcq
        }
       });
    item2.addActionListener(new ActionListener() 
      {
      public void actionPerformed(ActionEvent e) 
        {
        desktopCall(queryArray[1] + "/" + callsign);  // hamqth
        }
        });
    item3.addActionListener(new ActionListener() 
      {
      public void actionPerformed(ActionEvent e) 
        {
        desktopCall(queryArray[2] + "/call?callsign=" + callsign);  //hamcall.net
        }
        });
    item4.addActionListener(new ActionListener() 
      {
      public void actionPerformed(ActionEvent e) 
        {
        desktopCall(queryArray[3] + "/db/" + callsign);  //qrz.com
        }
        });
    item5.addActionListener(new ActionListener() 
      {
      public void actionPerformed(ActionEvent e) 
        {
        desktopCall(queryArray[4] + "/db/" + callsign);  // qrz.ru
        }
        });
    
     
    add(item1);
    add(item2);
    add(item3);
    add(item4);
    add(item5);
    logger.i("created PopUpCallsign");
    // component.addMouseListener(new PopClickListener());
    } // end constructor PopUpCallsign
  void desktopCall(String urilocal)
    {
    logger.tprintln("Calling desktop for URI=" + urilocal);
     try
       {
       if (Desktop.isDesktopSupported() && Desktop.getDesktop().isSupported(Desktop.Action.BROWSE)) 
         {
         Desktop.getDesktop().browse(new URI(urilocal));
         }
       }
    catch(URISyntaxException urise){logger.ee("Failed to invoke browser for " + urilocal, urise);}
    catch(IOException ioe){logger.ee("Failed to invoke browser for " + urilocal, ioe);}   
    }
} // end class PopUpCallsign



} // end class TableCallsign
