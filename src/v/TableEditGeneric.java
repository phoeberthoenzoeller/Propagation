/*
 * This class is an adaption of TableEditGeneric that is utilized to query and edit database tables.
 * This class does not accept a query from the user, but rather from the constructor.
 */
package v;
import v.File.ConfigureTextOutput;
import javax.swing.*;
import javax.swing.event.TableModelListener;
import javax.swing.event.TableModelEvent;
import java.awt.*;
import java.awt.event.*;
import java.sql.SQLException;
import m.Common;
import m.db.Database;
import m.db.ResultSetTableModel;
import java.sql.ResultSet;
import v.Log.Logfile;
import v.File.ExportToTextFileResultSet;
import javax.swing.JOptionPane;
import c.SQLiteUtils;
import javax.swing.table.TableModel;
import c.Time.TimeUtils;

/**
 *
 * @author chas
 */
public class TableEditGeneric extends javax.swing.JFrame
  {
  private Database dbl;
  private ResultSetTableModel rstmodel;
  private Logfile logger;
  private String queryStr;
  private String queryStrold;
  public boolean active=true;
  private int queryRowCount;
  private String[] textOutParams;
  private boolean suppressAddRow;
  
  /**
   * Creates new form QFrame
   */
  
  public TableEditGeneric(Database dbl, Logfile loggerl, String qs)
    {
    this.dbl=dbl;
    this.textOutParams = Common.getTextOutParams();
    this.queryStr=qs;
    if(loggerl==null) this.logger = Common.logger;
    else this.logger=loggerl;
    initComponents();
    Dimension screen = Toolkit.getDefaultToolkit().getScreenSize();
    this.setLocation(((screen.width - this.getSize().width) /2),((screen.height - this.getSize().height) / 2));
    this.ButtonCommit.setEnabled(false);
    this.ButtonRefresh.setEnabled(false);
    this.jButtonAddRow.setEnabled(false);
    this.suppressAddRow=false;
    this.displayQueryResults(this.dbl, this.qtable, this.queryStr, this.msgline, this.jLabelStatus, this.rstmodel);
    this.setVisible(true);
    } // end constructor

 
  
  
 
  
  /**
   * This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
  @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        qtable = new javax.swing.JTable();
        ButtonRefresh = new javax.swing.JButton();
        ButtonCommit = new javax.swing.JButton();
        msgline = new javax.swing.JLabel();
        jLabelStatus = new javax.swing.JLabel();
        jButtonAddRow = new javax.swing.JButton();
        jMenuBar1 = new javax.swing.JMenuBar();
        jMenu1 = new javax.swing.JMenu();
        jMenuItemConfigureTextOutput = new javax.swing.JMenuItem();
        jMenuItemDumpTabletoTextfile = new javax.swing.JMenuItem();
        jMenu2 = new javax.swing.JMenu();
        jMenu3 = new javax.swing.JMenu();
        jMenuHelpAbout = new javax.swing.JMenuItem();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setTitle("Query Window");
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent evt) {
                formWindowClosing(evt);
            }
        });

        jPanel1.setPreferredSize(new java.awt.Dimension(796, 596));

        jScrollPane1.setPreferredSize(new java.awt.Dimension(792, 550));

        qtable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "No data.  Please perform query."
            }
        ));
        qtable.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent evt) {
                qtableMousePressed(evt);
            }
        });
        jScrollPane1.setViewportView(qtable);

        ButtonRefresh.setText("Refresh");
        ButtonRefresh.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ButtonRefreshActionPerformed(evt);
            }
        });

        ButtonCommit.setText("Commit");
        ButtonCommit.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ButtonCommitActionPerformed(evt);
            }
        });

        jButtonAddRow.setText("Add Row");
        jButtonAddRow.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonAddRowActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addComponent(ButtonRefresh)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(ButtonCommit)
                        .addGap(7, 7, 7)
                        .addComponent(jButtonAddRow)
                        .addGap(18, 18, 18)
                        .addComponent(jLabelStatus, javax.swing.GroupLayout.PREFERRED_SIZE, 542, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(msgline, javax.swing.GroupLayout.DEFAULT_SIZE, 803, Short.MAX_VALUE)))
                .addContainerGap())
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGap(37, 37, 37)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(ButtonRefresh)
                    .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                        .addComponent(ButtonCommit)
                        .addComponent(jButtonAddRow))
                    .addComponent(jLabelStatus))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 494, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(msgline, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );

        jPanel1Layout.linkSize(javax.swing.SwingConstants.VERTICAL, new java.awt.Component[] {ButtonCommit, ButtonRefresh, jLabelStatus});

        msgline.getAccessibleContext().setAccessibleName("msgline");

        jMenu1.setText("File");

        jMenuItemConfigureTextOutput.setText("Configure Text Output");
        jMenuItemConfigureTextOutput.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemConfigureTextOutputActionPerformed(evt);
            }
        });
        jMenu1.add(jMenuItemConfigureTextOutput);

        jMenuItemDumpTabletoTextfile.setText("Dump Table to Textfile");
        jMenuItemDumpTabletoTextfile.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemDumpTabletoTextfileActionPerformed(evt);
            }
        });
        jMenu1.add(jMenuItemDumpTabletoTextfile);

        jMenuBar1.add(jMenu1);

        jMenu2.setText("Edit");
        jMenuBar1.add(jMenu2);

        jMenu3.setText("Help");

        jMenuHelpAbout.setText("About");
        jMenuHelpAbout.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuHelpAboutActionPerformed(evt);
            }
        });
        jMenu3.add(jMenuHelpAbout);

        jMenuBar1.add(jMenu3);

        setJMenuBar(jMenuBar1);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, 823, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

  private void formWindowClosing(java.awt.event.WindowEvent evt)//GEN-FIRST:event_formWindowClosing
  {//GEN-HEADEREND:event_formWindowClosing
  logger.i("FrameQuery Window closing");
  this.active=false;
  try{Thread.sleep(1000);}catch(InterruptedException ie){}
  // if(this.rstmodel != null)this.rstmodel.close(); finalizing the resultsettablemodel closes the connection
  // and since this class uses a shared connection then it will close the connection for other query frames.
  try{this.finalize();} 
  catch(Throwable t){};
  return;
  }//GEN-LAST:event_formWindowClosing

 public void finalizeFrameQuery() 
   {
   this.active=false;
   try{this.finalize();} 
   catch(Throwable t){};
   }
  
  public void tableChanged(TableModelEvent e)
  {
  logger.i("FrameQuery Table changed");
  }  
  
  
  
  private void ButtonCommitActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_ButtonCommitActionPerformed
  {//GEN-HEADEREND:event_ButtonCommitActionPerformed
  String retval;
  if(this.dbl.commit()) retval="Success"; else retval="Failure";
  logger.tprintln("Commit button pressed.  Commit result=" + retval); 
  this.jLabelStatus.setText(this.jLabelStatus.getText() + " Commit result=" + retval);
  }//GEN-LAST:event_ButtonCommitActionPerformed

  private void ButtonRefreshActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_ButtonRefreshActionPerformed
  {//GEN-HEADEREND:event_ButtonRefreshActionPerformed
  this.suppressAddRow=true;
  this.displayQueryResults(this.dbl, this.qtable, this.queryStr, this.msgline, this.jLabelStatus, this.rstmodel);
  }//GEN-LAST:event_ButtonRefreshActionPerformed

  private void jButtonAddRowActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_jButtonAddRowActionPerformed
  {//GEN-HEADEREND:event_jButtonAddRowActionPerformed
  // the addRow method is in ResultSetTableModel
  if(!this.rstmodel.addRow()) {logger.e("Failed to add row to table."); return;}
  try{  //flagme debug
  rstmodel.rsl.last();
  System.out.println("col 1=" + rstmodel.rsl.getString(1));
  }
  catch(SQLException se){System.err.println(se.getMessage());}
  this.displayQueryResults(this.dbl, this.qtable, this.queryStr, this.msgline, this.jLabelStatus, this.rstmodel);
  }//GEN-LAST:event_jButtonAddRowActionPerformed

  private void qtableMousePressed(java.awt.event.MouseEvent evt)//GEN-FIRST:event_qtableMousePressed
  {//GEN-HEADEREND:event_qtableMousePressed
  int rowCountl = this.qtable.rowAtPoint(evt.getPoint());
  // rows begin at 1 in resultset.  Left click is button1, right click is button3
  logger.i("FrameQuery qtable Mouse pressed, click count=" + evt.getClickCount() + ", button=" + evt.getButton() + ", row=" + rowCountl);
  // if(evt.getClickCount() < 2 || evt.getButton()!= 1) return;
  if(evt.getButton()==3) deleteRow(rowCountl + 1);
  }//GEN-LAST:event_qtableMousePressed

  private void jMenuItemConfigureTextOutputActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_jMenuItemConfigureTextOutputActionPerformed
  {//GEN-HEADEREND:event_jMenuItemConfigureTextOutputActionPerformed
  ConfigureTextOutput cto = new ConfigureTextOutput(Common.getTextOutParams());
  if(cto.savedFlag)this.textOutParams=cto.textOutParams;
  }//GEN-LAST:event_jMenuItemConfigureTextOutputActionPerformed

  private void jMenuItemDumpTabletoTextfileActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_jMenuItemDumpTabletoTextfileActionPerformed
  {//GEN-HEADEREND:event_jMenuItemDumpTabletoTextfileActionPerformed
   // dump current table to text file.
  try{if(this.rstmodel.rsl.isClosed()){logger.e("ResultSet is closed at start of ActionPerformed."); return;}}
  catch(SQLException sqle){logger.ee("Failed to get ResultSet.isClosed() call.", sqle); return;}
  logger.i("ResultSetTableModel table rowcount=" + this.rstmodel.getRowCount() + ", column count=" + this.rstmodel.getColumnCount());
  if(this.rstmodel.getType() == ResultSet.TYPE_FORWARD_ONLY) // e.g. SQLite   flagme testing .  this did no good.  delete me
    this.displayQueryResults(this.dbl, this.qtable, this.queryStr, this.msgline, this.jLabelStatus, this.rstmodel);
  ExportToTextFileResultSet etf = new ExportToTextFileResultSet(this.rstmodel,Common.getTextOutParams(),this.dbl.getDatabaseName() + "_tabledata", "Query Results Export to Text File");
  }//GEN-LAST:event_jMenuItemDumpTabletoTextfileActionPerformed

  private void jMenuHelpAboutActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_jMenuHelpAboutActionPerformed
  {//GEN-HEADEREND:event_jMenuHelpAboutActionPerformed
    Help_AboutBox dlg = new Help_AboutBox(this);
    Dimension dlgSize = dlg.getPreferredSize();
    Dimension frmSize = getSize();
    Point loc = getLocation();
    dlg.setLocation( (frmSize.width - dlgSize.width) / 2 + loc.x, (frmSize.height - dlgSize.height) / 2 + loc.y);
    dlg.setModal(true);
    dlg.pack();
    dlg.setVisible(true);

  }//GEN-LAST:event_jMenuHelpAboutActionPerformed

  
  
void deleteRow(int row)  
  {
  // Issue "are you sure" to operator.  Returns "0" for answer yes.
  int retVal=JOptionPane.showConfirmDialog(null,"Are you sure that we want to delete row " + row + "?", "Please confirm deletion.", JOptionPane.YES_NO_OPTION);  
  if(retVal != 0) return;
  logger.i("Operator has confirmed deleteion of row " + row + " in query results table for query=" + this.queryStr);
  this.rstmodel.deleteRow(row);
  this.displayQueryResults(this.dbl, this.qtable, this.queryStr, this.msgline, this.jLabelStatus, this.rstmodel);
  }
  

/**
 * This public method is provided so that a TableEditGeneric can be created populated with a passed query.
 * @param queryStr 
 */
public void displayQueryResults(String queryStr)
  {
  this.queryStr=queryStr;
  this.suppressAddRow=true;
  this.displayQueryResults(this.dbl, this.qtable, queryStr, this.msgline, this.jLabelStatus, this.rstmodel);
  }


/**
  * This method uses the supplied SQL query string, and the 
  * ResultSetTableModelFactory object to create a TableModel that holds
  * the results of the database query.  It passes that TableModel to the
  * JTable component for display.
  **/
public void displayQueryResults(final Database dblR, JTable qtableR, final String queryStrR, JLabel msglineR, JLabel status, ResultSetTableModel modell) 
  {
  // It may take a while to get the results, so give the user some
  // immediate feedback that their query was accepted.
  int typeInt, concurInt;
  String typeStr, concurStr;
  msglineR.setText("Performing query...");
  modell=this.performQuery(dblR, queryStrR);
  if(modell==null)return;
  logger.i("Getting resultset status.");
    // this.rstmodel = modell;  deleted 04/20/2017 as believed unnecessary.  this.rstmodel is passed as argument modell
    

  // In order to allow the feedback message to be displayed, we don't
  // run the query directly, but instead place it on the event queue
  // to be run after all pending events and redisplays are done.
  /* flagme following line is for test.  Please delete
  int rows = modell.getRowCount();  // this.tmToFile is TableModel of query
  int cols = modell.getColumnCount();
  String fileName="testfile.txt";
  logger.i("Writing to file=" + fileName + ", row count=" + rows + ", column count=" + cols);
  String[] colNames = new String[cols];
  for(int i=1; i < cols; i++) {colNames[i]=modell.getColumnName(i); System.out.println("col#" + i + "=" + colNames[i]); } 
  */ 
  EventQueue.invokeLater(new Runnable() 
    {
    public void run() 
      {
      // We're done, so clear the feedback message
      msglineR.setText("Query complete");  
      } // end run
  });
  this.ButtonCommit.setEnabled(true);
  this.ButtonRefresh.setEnabled(true);
  try
    {
    typeInt= modell.getType(); typeStr= dblR.getResultSetStatus(modell.rsl.getType());
    concurInt= dblR.ResultSetDB.getConcurrency(); concurStr=dblR.getResultSetStatus((modell.rsl.getConcurrency()));
    }
  catch(SQLException se){logger.ee("Failed getType() or getConcurrency()=" + queryStrR, se); return;}
  logger.i(dblR.getRowCount() + " rows returned.  Type=" + typeInt + "(" + typeStr + "), Concurrency=" + concurInt + "(" + concurStr + ")");
  if(typeInt != 1003 &&  concurInt==1008)
    {
    logger.i("Setting ButtonAddRow to visible because type=" + typeInt + " and concurrency=" + concurInt);
    this.jButtonAddRow.setEnabled(true);
    // this.jButtonAddRow.setVisible(true);
    // this.jButtonAddRow.paintImmediately(0, 0, 100, 100);
    }
  else 
    {
    logger.i("Setting ButtonAddRow to disabled because type=" + typeInt + " and concurrency=" + concurInt);
    logger.i("NOTICE: Remember that the ResultSet may be read-only, but that does not necessarily mean that the table(s) are.  Go ahead and try a manual insert into statement.");
    this.jButtonAddRow.setEnabled(false);
    }
  status.setText(dblR.getRowCount() + " rows returned.  Type=" + typeStr + ", Concurrency=" + concurStr);
  this.queryStrold = this.queryStr;  
  if(modell.getType() != ResultSet.TYPE_FORWARD_ONLY) // e.g. SQLite
    qtableR.setModel(modell);
  else // for TYPE_FORWARD_ONLY e.g. SQLite
    {
    SQLiteUtils se = new SQLiteUtils(logger); 
    se.liteTableModel(modell.rsl, qtableR); // this will close modell ResultSet, e.g. modell.rsl.isClosed()=true.
    // Perform query anew to refresh ResultSetTableModel
    modell=this.performQuery(dblR, queryStrR);
    }
  this.suppressAddRow=false;
  if(modell==null){logger.e("Null model produced from query."); return;}
  this.rstmodel = modell;
  try{logger.println("ResultSetTableModel rowcount=" + modell.getRowCount() + ", ResultSet.isClosed()=" + modell.rsl.isClosed()); }
  catch(SQLException se){logger.ee("Failed to get ResultSet.isClosed status.",se); return;}
  } // end displayQueryResults  
  

ResultSetTableModel performQuery(final Database dblR,final String queryStrR)
  {
  ResultSetTableModel modell =null;
  try{modell=dblR.selectT(queryStrR);}
  catch(SQLException sqle){logger.ee("Failed Database.selectT(" + queryStr + ")",sqle); return null;}
  if(modell==null){logger.e("Null model in FrameQuery.displayQueryResults."); return null;}
  modell.addTableModelListener(new TableEditGeneric.TML());
  try{logger.println("ResultSetTableModel rowcount=" + modell.getRowCount() + ", ResultSet.isClosed()=" + modell.rsl.isClosed()); }
  catch(SQLException se){logger.ee("Failed to get ResultSet.isClosed status.",se); return null;}
  return modell;
  }



/**
  * This method uses the supplied command string
  * to perform a JDBC command against the specified database.
  **/
public void performSQLJDBC(final Database dblR, JTable qtableR, final String queryStrR, JLabel msglineR, JLabel status, ResultSetTableModel modell) 
  {
  msglineR.setText("Performing command " + queryStr);
  boolean retSuc;
  logger.i("Performing command=" + queryStr);
  retSuc=dblR.SQLJDBC(queryStr);
  logger.i("Command success=" + retSuc);
  status.setText("Command success=" + retSuc);
  msglineR.setText("Command complete");  
  this.suppressAddRow=true;
  if(this.queryStrold != null) this.displayQueryResults(dblR, qtableR, this.queryStrold, msglineR, status, modell);
  } // end performSQLJDBC
  




/**
 * Determines whether the passed query statement is a create statement.
 * @return boolean
 */
private boolean isCreateorDrop(String queryStrlocal)
  {
  String startsWith;
  startsWith=queryStrlocal.substring(0,6).toLowerCase();
  logger.i("Command starts with=" + startsWith);
  if(startsWith.equals("create")) return true;
  startsWith=queryStrlocal.substring(0,4).toLowerCase();
  if(startsWith.equals("drop")) return true;
  else return false;
  }


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton ButtonCommit;
    private javax.swing.JButton ButtonRefresh;
    private javax.swing.JButton jButtonAddRow;
    private javax.swing.JLabel jLabelStatus;
    private javax.swing.JMenu jMenu1;
    private javax.swing.JMenu jMenu2;
    private javax.swing.JMenu jMenu3;
    private javax.swing.JMenuBar jMenuBar1;
    private javax.swing.JMenuItem jMenuHelpAbout;
    private javax.swing.JMenuItem jMenuItemConfigureTextOutput;
    private javax.swing.JMenuItem jMenuItemDumpTabletoTextfile;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JLabel msgline;
    private javax.swing.JTable qtable;
    // End of variables declaration//GEN-END:variables
 


class TML implements TableModelListener
    {
    public void tableChanged(TableModelEvent e) 
          {
          logger.tprintln("TableChanged in QFrame.java. TableModelEvent=" + e.toString());
          }
    }

 } // end class QFrame